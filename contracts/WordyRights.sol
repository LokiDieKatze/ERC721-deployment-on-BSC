//SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

///@title WYR: an NFT-based copyright creator
///@author Sarah M.

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/Address.sol";

contract WordyRights is ERC721Enumerable, ERC721URIStorage, AccessControl {
    using Counters for Counters.Counter;
    using Strings for uint256;
    using Address for address payable;

    struct Copyright {
        bytes32 textHash;
        address owner;
        uint256 timeStamp;
        bool _isForSale;
        uint256 _WYRPrice;
    }

    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    Counters.Counter private _ids;
    mapping(uint256 => Copyright) private _copyrights;
    mapping(uint256 => address) private _owners;
    mapping(uint256 => bool) private _isForSale;
    mapping(uint256 => uint256) private _WYRPrice;

    constructor() ERC721("WordyRights", "WYR") {
        _setupRole(MINTER_ROLE, msg.sender);
    }

    ///@param textHash the keccak256 hash from the user's text
    ///@notice the hash is automatically generated by the dapp, you only have to enter the text
    ///@dev the id count ensures a unique id for each WYR which is directly minted to his creator
    function createRights(bytes32 textHash) public returns (uint256) {
        _ids.increment();
        uint256 currentId = _ids.current();
        _mint(msg.sender, currentId);
        _owners[currentId] = msg.sender;
        _copyrights[currentId] = Copyright(textHash, msg.sender, block.timestamp, false, 0);
        return currentId;
    }

    ///@param price the price you set for the sale of your WYR
    ///@param copyrightId the id of the WYR you wish to sell
    ///@notice you must be the owner of the WYR and it must not already be on sale
    ///@dev the approve function allows this contract to perform the transfer when a user buys the WYR 
    function setForSale(uint256 price, uint256 copyrightId) public {
        require(msg.sender == _owners[copyrightId], "WYRs can only be managed by their owners.");
        _isForSale[copyrightId] = true;
        _WYRPrice[copyrightId] = price;
        approve(address(this), copyrightId);
    }

    ///@param copyrightId the id of the WYR you wish to withdraw from sale
    ///@notice you must be the owner of the WYR and it must be on sale
    function notForSale(uint256 copyrightId) public {
        require(msg.sender == _owners[copyrightId], "WYRs can only be managed by their owners.");
        require(_isForSale[copyrightId] == true, "This WYR is not for sale.");
        _isForSale[copyrightId] = false;
        _WYRPrice[copyrightId] = 0;
    }

    ///@param copyrightId the id of the WYR you wish to buy
    ///@notice you can not be the owner, the WYR must be for sale and you must enter the price that matches the WYR as your transaction value
    function buyWYR (uint256 copyrightId) public payable {
        require(_isForSale[copyrightId] == true, "This WYR is not for sale.");
        require(msg.value == _WYRPrice[copyrightId], "Please enter the price matching the WYR you are willing to buy.");
        _buyWYR(_owners[copyrightId], msg.sender, copyrightId);
    }

    ///@dev function that allows the buyer to send ETHER against WYR
    receive() external payable {
    }

    ///@dev after the contracts receives ETHER, it transfers it to the seller, then it calls _transfer function that carries out the WYT transfer
    function _buyWYR(address seller, address buyer, uint256 copyrightId) internal virtual {
        payable(seller).sendValue(_WYRPrice[copyrightId]);
        _transfer(seller, buyer, copyrightId);
        _isForSale[copyrightId] = false;
        _copyrights[copyrightId].owner = buyer;
    }

    ///@param copyrightId the id of the WYR you are interested in, find out if it's for sale
    function isForSale(uint256 copyrightId) public view returns (bool) {
        return _isForSale[copyrightId];
    }

    ///@param copyrightId the id of the WYR you are interested in, find out its price
    function WYRPrice(uint256 copyrightId) public view returns (uint256) {
        return _WYRPrice[copyrightId];
    }

    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Enumerable, ERC721, AccessControl) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721Enumerable, ERC721) {
        super._beforeTokenTransfer(from, to, tokenId);
    }

    ///@dev allows the minter to burn WYRs in case of misuse or fraud
    function _burn(uint256 tokenId) internal virtual onlyRole(MINTER_ROLE) override (ERC721URIStorage, ERC721) {
        super._burn(tokenId);
    }
    
    function tokenURI(uint256 tokenId) public view virtual override(ERC721, ERC721URIStorage) returns (string memory) {
        return super.tokenURI(tokenId);
    }
}
